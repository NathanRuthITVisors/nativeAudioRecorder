// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import { Big } from "big.js";

// BEGIN EXTRA CODE
// END EXTRA CODE

/**
 * @param {string} pageName - Format: Module/PageName (It is a path to a file rather than a qualified model object name)
 * @param {MxObject} contextObject - Optional. The context object to pass to the page.
 * @param {"NanoflowCommonsITvisors.ShowPageOpenType.content"|"NanoflowCommonsITvisors.ShowPageOpenType.popup"|"NanoflowCommonsITvisors.ShowPageOpenType.modal"} openType - In content (full page) or popup?
 * @param {boolean} waitForClose - Wait for the page to close. Only possible when opening as popup, ignore otherwise.
 * @param {string} title - Optional, to override the page titile
 * @param {string} popupCssSelector - Only applicable when waiting for the popup to close. CSS selector to find the (poup) page we just opened. Something like div.MyPopup. The MyPopup class must be set on your page but need not exist in your CSS.
 * @returns {Promise.<boolean>}
 */
export async function ShowPage(pageName, contextObject, openType, waitForClose, title, popupCssSelector) {
	// BEGIN USER CODE
	return new Promise(function(resolve, reject) {

		try {
			var context,
				params,
				afterOpenCallback,
				callOpenFormApi,
				rejectWithMessage,
				useOpenCallback = false,
				OPEN_TYPE_CONTENT = "content";

			afterOpenCallback = function () {
				var observer = new MutationObserver(function (mutations) {
					var dialogVisible = false;

					// Attempt to find the popup.
					mutations.forEach(function (mutation) {
						if (document.querySelector(popupCssSelector)) {
							dialogVisible = true;
						}
					});

					if (!dialogVisible) {
						observer.disconnect();
						resolve(true);
					}
				});
				observer.observe(document.body, { attributes: false, childList: true, characterData: false });
			};

			callOpenFormApi = function () {
				mx.ui.openForm(pageName + ".page.xml", params);
				// When not waiting for the popup to close, we're done so resolve immediately.
				if (!useOpenCallback) {
					resolve(true);
				}
			};

			rejectWithMessage = function (message) {
				reject(Error("ShowPage: " + message));
			};

			if (typeof pageName === "undefined" || !pageName) {
				rejectWithMessage("Page name not specified");
				return;
			}

			if (typeof openType === "undefined" || !openType) {
				rejectWithMessage("Open type not specified");
				return;
			}

			params = {
				location: openType
			};

			// Upon opening page in content, current page will be destroyed. No chance to wait for close. Mendix API will not call the callback function anyway.
			if (openType !== OPEN_TYPE_CONTENT && waitForClose) {
				params.callback = afterOpenCallback;
				useOpenCallback = true;
			}

			if (typeof title !== "undefined" && title) {
				params.title = title;
			}

			// If there is a context object, use it.
			if (typeof contextObject !== "undefined" && contextObject) {
				// Create a context for it and open the form.
				context = new mendix.lib.MxContext();
				context.setTrackObject(contextObject);
				params.context = context;
				callOpenFormApi();
			} else {
				callOpenFormApi();
			}
		} catch (error) {
			if (error) {
				reject(error);
			} else {
				reject("ShowPage failed.");
			}
		}
	});
	// END USER CODE
}
